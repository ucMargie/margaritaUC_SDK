import { CONSENT_ACTION, CONSENT_TYPE } from '../../services/DataFacade/enums';
import { ConsentHistory, DataFacadeService, DataTransferObject } from '../../services/DataFacade/interfaces';
import { IntMap, UcDomains } from '../../interfaces';
import Core from '../../services/SettingsV2/Core';
import { IdAndName } from '../../index.legacy';
export declare const arrayContainsValue: <T>(array: T[], value: T) => boolean;
export declare const getApplicationVersion: () => string;
export declare const getTcfCmpVersion: () => number;
export declare const isArrayWithElements: (array: unknown) => boolean;
export declare const isObjectWithValues: (object: unknown) => boolean;
export declare const isValidJsonString: (str: string, identifier: string) => boolean;
export declare const nullishOperation: <T>(element: T | null | undefined, altElement: T) => T;
export declare const replaceElementInDOM: (oldElement: HTMLElement, newElement: HTMLElement) => void;
export interface DataTransferSettings extends Pick<Core, 'id' | 'version'> {
    controllerId: string;
    selectedLanguage: string;
}
export declare const mapDataTransferObject: (dataTransferSettings: DataTransferSettings, service: DataFacadeService, consentAction: CONSENT_ACTION, consentType: CONSENT_TYPE, options?: {
    referrerControllerId?: string | undefined;
    timestamp?: number | undefined;
} | undefined) => DataTransferObject;
export declare const reduceIdAndName: <T extends IdAndName>(ids: number[], source: IntMap<T>) => IdAndName[];
/**
 * This helper mimics lodash/uniq
 * @param arr Array
 */
export declare function uniq<T>(arr: Array<T> | null | undefined): Array<T>;
/**
 * This helper mimics lodash/uniqWith
 * @param arr Array
 * @param comparator function comparator
 */
export declare function uniqWith<T>(arr: Array<T>, comparator: (arg0: any, arg1: any) => any): Array<T>;
/**
 * This helper mimics lodash/sortBy but returns ascending order only
 * @param arr Array
 * @param iterator property name in string format
 */
export declare function sortByAsc<T>(arr: Array<T>, iterator: keyof T): T[];
/**
 * This helper checks if the given date is after the current date
 * @param date Date
 */
export declare const isDatePassed: (date: Date) => boolean;
export declare const getConsentActionConsentHistoryOrderedByTimestamp: (history: ConsentHistory[]) => ConsentHistory[];
/**
 * Substitute for Promise.all
 */
export declare function promiseAll(promises: Promise<unknown>[]): Promise<unknown>;
/**
 * Substitute for Promise.race
 * "Invert the polarity of the promises, and then you can use Promise.all,
 *  because it rejects on the first rejected promise, which after inversion
 *  corresponds to the first fulfilled promise"
 */
export declare function firstOfPromises(ps: Promise<unknown>[]): Promise<unknown>;
export declare const mergeDeep: <T, U>(target: T, original: U, isMergingArrays?: boolean) => U;
export declare const waitUntil: (condition: () => boolean, timeoutMessage: string, timeout?: number, interval?: number) => Promise<void>;
export declare const getUcDomains: (domains?: UcDomains | undefined) => UcDomains | null;
export declare const compareSemanticVersions: (a: string, b: string) => number;
