import { CoreTcf, LegacyTCF2ChangedPurposes } from '../../services/Api/interfaces';
import { Feature, GVL, IntMap, Purpose, PurposeRestrictionVector, Stack, TCModel } from '@iabtcf/core';
import { ResurfaceOptions, TCFChangedPurposes } from '../../services/SettingsV2/interfaces';
import { TCFFeature, TCFPurpose, TCFSpecialFeature, TCFSpecialPurpose, TCFStack, TCFVendor, TCFVendorRestriction } from '../..';
import { Maybe } from '../../services/SettingsV2/interfaces/interfaces';
import { StorageTCF } from '../../services/Storage/interfaces';
export declare const generateVendorsFromGVL: (tcModel: Maybe<Pick<TCModel, 'gvl' | 'publisherRestrictions' | 'vendorConsents' | 'vendorLegitimateInterests'>>, disabledSpecialFeatures: number[], useGranularChoice: boolean, hideLegitimateInterestToggles: boolean, purposeOneTreatment: boolean, vendorIdsOutsideEUList: number[]) => TCFVendor[];
export declare const getChangePurposes: (changedPurposes: Maybe<LegacyTCF2ChangedPurposes>) => TCFChangedPurposes;
export declare const getConsensuScriptPath: (consensuScriptPath: Maybe<string>) => string;
export declare const getConsensuSubdomain: (consensuDomain: Maybe<string>) => string;
export declare const getFeatureIdsFromVendors: (vendors: Pick<TCFVendor, 'features'>[]) => number[];
export declare const getFeaturesFromVendors: (vendors: TCFVendor[], features?: Maybe<IntMap<Feature>>) => TCFFeature[];
export declare const getGranularChoice: (firstLayerHideToggles: boolean, secondLayerHideToggles: boolean) => boolean;
export declare const getIsVendorDisclosed: (vendorId: number, vendorsDisclosed?: import("../../services/Storage/interfaces").StorageTCFVendorsDisclosed) => boolean;
export declare const getPurposeIdsFromVendorsAndStacks: (tcModelStacks: Maybe<IntMap<Stack>>, vendors: TCFVendor[], disabledSpecialFeatures: number[], selectedStackIds: number[], purposeOneTreatment: boolean) => number[];
export declare const getPurposesFromVendors: (tcModel: Maybe<Pick<TCModel, 'purposeConsents' | 'purposeLegitimateInterests'>>, tcModelStacks: Maybe<IntMap<Stack>>, tcModelPurposes: Maybe<IntMap<Purpose>>, vendors: TCFVendor[], disabledSpecialFeatures: number[], selectedStackIds: number[], purposeOneTreatment: boolean, useGranularChoice: boolean, hideLegitimateInterestToggles: boolean) => TCFPurpose[];
export declare const getResurfaceOptions: (tcf2: Pick<CoreTcf, 'resurfaceIABLegalBasisChanged' | 'resurfacePeriodEnded' | 'resurfacePurposeChanged' | 'resurfaceVendorAdded'>) => ResurfaceOptions;
export declare const getSpecialFeatureIdsFromVendorsAndStacks: (tcModelStacks: Maybe<IntMap<Stack>>, vendors: TCFVendor[], disabledSpecialFeatures: number[], selectedStackIds: number[]) => number[];
export declare const getSpecialFeaturesFromVendorsAndStacks: (tcModel: Maybe<Pick<TCModel, 'specialFeatureOptins'>>, tcModelGvl: Maybe<Pick<GVL, 'stacks' | 'specialFeatures'>>, vendors: TCFVendor[], disabledSpecialFeatures: number[], selectedStackIds: number[], useGranularChoice: boolean) => TCFSpecialFeature[];
export declare const getSpecialPurposeIdsFromVendors: (vendors: Pick<TCFVendor, 'specialPurposes'>[]) => number[];
export declare const getSpecialPurposesFromVendors: (specialPurposes: Maybe<IntMap<Purpose>>, vendors: TCFVendor[]) => TCFSpecialPurpose[];
export declare const getStacks: (stacks: Maybe<IntMap<Stack>>, disabledSpecialFeatures: number[], selectedStackIds: number[]) => TCFStack[];
export declare const getPublisherRestriction: (publisherRestrictions: Maybe<PurposeRestrictionVector>) => TCFVendorRestriction[];
export declare const isResurfacePeriodEnded: (previousStorage: Maybe<StorageTCF>) => boolean;
export declare const isTcfVersionChanged: (previousStorage: Maybe<StorageTCF>, tcModel: Maybe<Pick<TCModel, 'policyVersion' | 'version'>>) => boolean;
export declare const isVendorAdded: (previousStorage: Maybe<StorageTCF>, vendors: TCFVendor[]) => boolean;
export declare const isVendorPurposeChanged: (previousStorage: Maybe<StorageTCF>, vendors: TCFVendor[]) => boolean;
export declare const mapStorageVendors: (vendors: TCFVendor[]) => (number | number[])[][];
export declare const resolveLanguage: (language: string) => string;
