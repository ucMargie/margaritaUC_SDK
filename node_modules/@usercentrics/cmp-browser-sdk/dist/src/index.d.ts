import { AMP_CONSENT_ACTION, AMP_CONSENT_TYPE } from './services/AMP/enums/enums';
import { AriaLabelsTranslation, LegacySettings } from './services/Api/interfaces';
import { BaseCategory, BaseService, Category, Maybe, Service, UserDecision } from './services/SettingsV2/interfaces';
import { CONSENT_TYPE } from './services/DataFacade/enums';
import { DataTransferObject, TrackEventParameters } from './services/DataFacade/interfaces';
import { InitOptions, InitialUIValues, UI_LAYER, UcDomains } from './interfaces';
import { Settings } from './services/Settings/interfaces';
import { TCFData, TCFUserDecisions } from './services/SettingsV2/interfaces/TCF';
import { WINDOW_MOBILE_SDK_NAMESPACE, WINDOW_UC_UI_DOMAINS } from './constants';
import Core from './services/SettingsV2/Core';
import { Data } from './services/SettingsV2/Data/interfaces';
import { GlobalFunction } from './services/SettingsV2/interfaces/Ccpa/interfaces.public';
import { Labels } from './services/SettingsV2/Labels/interfaces';
import { UI as SettingsUI } from './services/SettingsV2/UI/interfaces';
import { TCF_DECISION_UI_LAYER } from './services/SettingsV2/enums/TCF';
import { UserCountryData } from './services/Location/interfaces';
import { WINDOW_API_NAME } from './services/SettingsV2/constants/Ccpa/constants';
export * from './services/DataFacade/enums/enums.public';
export * from './services/DataFacade/interfaces/interfaces.public';
export * from './services/Location/interfaces/interfaces.public';
export * from './services/Settings/interfaces/interfaces.ui.public';
export * from './services/Settings/interfaces/interfaces';
export * from './services/SettingsV2/Core/interfaces';
export * from './services/SettingsV2/enums/Ccpa/enums.public';
export * from './services/SettingsV2/enums/enums.public';
export * from './services/SettingsV2/enums/TCF/enums.public';
export * from './services/SettingsV2/interfaces/interfaces.default.public';
export * from './services/SettingsV2/interfaces/interfaces';
export * from './services/SettingsV2/interfaces/TCF/interfaces.decisions.public';
export * from './services/SettingsV2/interfaces/TCF/interfaces.public';
export * from './services/SettingsV2/UI/interfaces';
export { AriaLabelsTranslation } from './services/Api/interfaces/interfaces.legacy';
export { CLOSE_OPTION } from './services/Api/enums/enums.legacy';
export { Data } from './services/SettingsV2/Data/interfaces';
export { default as Core } from './services/SettingsV2/Core';
export { CookieInformationLabels, DefaultGeneralLabels, DefaultLabels, Labels, TcfLabels as TcfUISettingsLabels, } from './services/SettingsV2/Labels/interfaces';
export { InitOptions, InitialUIValues, UI_LAYER, UI_VARIANT } from './interfaces';
export { DeviceStorage, Disclosure } from './services/Api/interfaces/interfaces.legacy';
export { isCcpaData, isCcpaLabels, isCcpaUI, isDefaultData, isDefaultLabels, isDefaultUI, isPrivacyButtonUI, isTcfData, isTcfLabels, isTcfUI, } from './services/SettingsV2/helpers';
declare global {
    interface Window {
        [WINDOW_UC_UI_DOMAINS]: UcDomains;
        [WINDOW_API_NAME]: GlobalFunction;
        [WINDOW_MOBILE_SDK_NAMESPACE]: {
            getUserSessionData: () => string;
        };
    }
}
declare type SettingsId = string;
declare type RulesetId = string;
declare class Usercentrics {
    private ampInstance;
    private apiInstance;
    private botInstance;
    private controllerIdInstance;
    private dataFacadeInstance;
    private eventDispatcherInstance;
    private initOptions;
    private languageInstance;
    private locationInstance;
    private settingsV2;
    private uiInstance;
    private domains;
    private rulesetRule;
    /**
     * @param ucId - Your unique Usercentrics Id - settingsId or rulesetId
     * @param options - Additional options for initialization of the SDK. Note especially the createTcfApiStub property which is necessary for TCF UIs.
     */
    constructor(ucId: SettingsId | RulesetId, options?: InitOptions);
    /**
     * Initializes the Usercentrics framework. This method *must* be called when loading your website.
     * The return value defines which UI layer & variant you should initially show for your users.
     * @category General
     */
    init(): Promise<InitialUIValues>;
    /**
     * Mark all disclosed TCF vendors, purposes, specialFeatures as "consent given" and if applicable "legitimate interest given".
     * The SDK will store the consent information and trigger TCF events.
     * NOTE: This function will also mark the TCF UI as being closed! No need to call the setTCFUIAsClosed() method.
     * @param fromLayer - The layer from which the consent was given/denied (firstLayer vs. secondLayer).
     * @category TCF
     */
    acceptAllForTCF(fromLayer: TCF_DECISION_UI_LAYER): Promise<void>;
    /**
     * Mark all services as "Consent given" (e.g. an "Accept All" button was clicked).
     * The SDK will store the consent information and trigger events depending on your Usercentrics Settings.
     * @param consentType - The manner in which the consent was given (explicit vs. implicit). Default: explicit.
     * @category Non-TCF
     */
    acceptAllServices(consentType?: CONSENT_TYPE): Promise<void>;
    /**
     * Change the language. All upcoming SDK calls will return information in this language (e.g. getSettings(),getCategories(), getTCFData(), ...).
     * Pay attention that the language needs to be set up in your Usercentrics Admin Interface before!
     * @param language - The language to switch to (ISO 639-1 code)
     * @category General
     */
    changeLanguage(language: string): Promise<void>;
    /**
     * Mark all disclosed TCF vendors, purposes, specialFeatures as "consent denied" and if applicable "legitimate interest denied".
     * The SDK will store the consent information and trigger TCF events.
     * NOTE: This function will also mark the TCF UI as being closed! No need to call the setTCFUIAsClosed() method.
     * @param fromLayer - The layer from which the consent was given/denied (firstLayer vs. secondLayer).
     * @category TCF
     */
    denyAllForTCF(fromLayer: TCF_DECISION_UI_LAYER): Promise<void>;
    /**
     * Mark all services as "Consent denied" (e.g. a "Deny All" button was clicked).
     * *Essential* services will still be marked as "Consent given".
     * The SDK will store the consent information and trigger events depending on your Usercentrics Settings.
     * @param consentType - The manner in which the consent was denied (explicit vs. implicit). Default: explicit.
     * @category Non-TCF
     */
    denyAllServices(consentType?: CONSENT_TYPE): Promise<void>;
    /**
     * Retrieve boolean, that can be used to decide if the user is inside the EU or not.
     * @category Non-TCF
     */
    fetchIsUserInEU(): Promise<boolean>;
    /**
     * Retrieve the user's country information.
     * @category Non-TCF
     */
    fetchUserCountry(): Promise<UserCountryData>;
    /**
     * Retrieve ab testing variant in use.
     */
    getAbTestVariant(): string;
    /**
     * Retrieve the categories and their services to display this information in your UI.
     * @deprecated since version 2.2.0-beta.3
     * Will be deleted in version 3.0.
     *
     * In case you need similar behavior, use getCategoriesBaseInfo or getCategoriesFullInfo
     *
     * @category Non-TCF
     */
    getCategories(): Category[];
    /**
     * Retrieve the categories and their base services info to display this information in your UI.
     * @category Non-TCF
     */
    getCategoriesBaseInfo(): BaseCategory[];
    /**
     * Retrieve the categories and their full services info to display this information in your UI.
     * @category Non-TCF
     */
    getCategoriesFullInfo(): Promise<Category[]>;
    /**
     * Retrieve optout status of ccpa
     * @category CCPA
     */
    getCcpaOptOutStatus(): boolean;
    /**
     * Set optout status in cookie for user and save string in backend
     * @param isOptedOut - User's decision on all consents
     * @category CCPA
     */
    saveOptOutForCcpa(isOptedOut: boolean, consentType?: CONSENT_TYPE): Promise<void>;
    /**
     * Don't perform any changes on consent level. Stores the timestamp and set userActionPerformed
     * @category CCPA
     */
    saveDefaultForCcpa(): Promise<void>;
    /**
     * Retrieve the controllerId, that's generated for the user.
     * @category General
     */
    getControllerId(): string;
    /**
     * Retrieve all services.
     * @deprecatedsince version 2.2.0-beta.3
     * Will be deleted in version 3.0.
     *
     * In case you need similar behavior, use getServicesBaseInfo or getCategoriesFullInfo
     *
     * @category Non-TCF
     */
    getServices(): Service[];
    /**
     * Retrieve all services without fetching the aggregator.
     * @category Non-TCF
     */
    getServicesBaseInfo(): BaseService[];
    /**
     * Retrieve all services fetching the aggregator if necessary.
     * @category Non-TCF
     */
    getServicesFullInfo(): Promise<Service[]>;
    /**
     * Retrieve all settings.
     * @category General
     */
    getSettings(): Settings;
    /**
     * Retrieve settings Core
     * @category General
     */
    getSettingsCore(): Core;
    /**
     * Retrieve settings Labels
     * @category General
     */
    getSettingsLabels(): Labels;
    /**
     * Retrieve settings Data
     * @category General
     */
    getSettingsData(): Maybe<Data>;
    /**
     * Retrieve settings Data
     * @category General
     */
    getSettingsUI(): Maybe<SettingsUI>;
    /**
     * Retrieve aria labels
     * @category General
     */
    getAriaLabels(): AriaLabelsTranslation;
    /**
     * Retrieve all TCF data, including consents and descriptions for TCF vendors, purposes, special purposes, features, special features, and stacks
     * Only vendors and stacks that have been selected in the admin interface will be returned. Only purposes, features, special features, special purposes
     * that are used by one or more of the selected vendors (and/or selected stacks) will re returned.
     * @category TCF
     */
    getTCFData(): TCFData | null;
    /**
     * A method to return TCF disclosed vendors as an encoded segment
     * @category TCF
     *
     * @returns {(string|undefined)} the TCF disclosed vendors segment or undefined
     */
    getTCFDisclosedVendorsSegmentString(): string | undefined;
    /**
     * Inject a tcString
     * @category TCF
     *
     * @param tcString the tcString to inject
     *
     * @returns boolean true if injected successfully, false otherwise
     */
    injectTCString(tcString: string): Promise<boolean>;
    /**
     * Mark the TCF UI as being closed and trigger related TCF events.
     * NOTE: Remember to call this ALWAYS when an end-user closes your TCF UI without making any changes!
     * @category TCF
     */
    setTCFUIAsClosed(): Promise<void>;
    /**
     * Mark the TCF UI as being open and trigger related TCF events.
     * NOTE: Remember to call this ALWAYS when an end-user opens up your TCF UI!
     * @category TCF
     */
    setTCFUIAsOpen(): Promise<void>;
    /**
     * Mark given TCF vendors, purposes, specialFeatures as "consent given / denied" and if applicable "legitimate interest given denied".
     * The SDK will store the consent information and trigger TCF events.
     * NOTE: This function will also mark the TCF UI as being closed! No need to call the setTCFUIAsClosed() method.
     * @param decisions - The user's decisions for individual TCF vendors, purposes,  specialFeatures (see interface definition for details)
     * @param fromLayer - The layer from which the consent was given/denied (firstLayer vs. secondLayer).
     * @category TCF
     */
    updateChoicesForTCF(decisions: TCFUserDecisions, fromLayer: TCF_DECISION_UI_LAYER): Promise<void>;
    /**
     * Return if the user accepted all consents
     * @category General
     */
    areAllConsentsAccepted(): boolean;
    /**
     * Restore a session for an end user with the given controllerId.
     * @param controllerId - User's generated controllerId. NOTE: Always use a controllerId provided by the SDK.
     * @category Non-TCF
     */
    restoreUserSession(controllerId: string): Promise<void>;
    /**
     * Clear the storage from all buckets
     */
    clearStorage(): Promise<void>;
    /**
     * This method sends the message to the parent iframe to communicate the user's decisions
     * @param type the AMP consent type
     * @param action the AMP consent action
     */
    postMessageAmp(type: AMP_CONSENT_TYPE, action: AMP_CONSENT_ACTION, initialHeight?: string): Promise<void>;
    /**
     * Accept all services for AMP
     */
    acceptAllAmp(): Promise<void>;
    /**
     * Reject all services for AMP
     */
    denyAllAmp(): Promise<void>;
    /**
     * Save current TCF data based on user decisions according to the rules below:
     * - if there are only TCF vendors and no non-IAB-service - we signal accept
     * - if the are non-IAB services and ALL of them have a consent we signal accept
     * - if the are non-IAB services and at least ONE of them has NO consent we signal reject
     * @param tcfUserDecisions TCF user decisions from the UI
     * @param userDecisions User decision from the UI
     */
    saveTCFDataAmp(userDecisions: UserDecision[]): Promise<void>;
    /**
     * Dismiss UI for AMP - this closes the AMP UI and also don't change the consent.
     * If a consent has already been given, AMP uses that as the current state.
     */
    dismissAmp(): Promise<void>;
    /**
     * Enter fullscreen mode on AMP UI
     */
    enterFullscreenAmp(): Promise<void>;
    /**
     * Sends the ready message to display the AMP UI
     */
    uiReadyAmp(): Promise<void>;
    /**
     * Set user action performed. Only needed if a user action is performed without the need for an explicit consent (e.g. CCPA first layer implementation)
     * @category General
     */
    saveUserActionPerformed(): Promise<void>;
    /**
     * Mark given services as "Consent given / denied".
     * *Essential* services will still be marked as "Consent given".
     * The SDK will store the consent information and trigger events depending on your Usercentrics Settings.
     * @param decisions - The user's decisions for individual services (see interface definition for details)
     * @param consentType - The manner in which the consent was given/denied (explicit vs. implicit). Default: explicit.
     * @category Non-TCF
     */
    updateServices(decisions: UserDecision[], consentType?: CONSENT_TYPE): Promise<void>;
    updateLayer(activeLayer: UI_LAYER): Promise<void>;
    /**
     * Fetch service data from the aggregator if the data wasn't fetched already
     */
    loadServices(): Promise<void>;
    loadSettings(): Promise<LegacySettings>;
    updateStorage(storageDataTransferObjects?: DataTransferObject[], isRestoreSession?: boolean): Promise<void>;
    /**
     * Needed for enabling dynamically loaded script.
     */
    enableScriptsForServicesWithConsent(): void;
    setTrackingPixel(trackEventParameters: TrackEventParameters): void;
    private addTrackingPixel;
    private processStorageServicesAndSettings;
    private enableServicesScripts;
}
export default Usercentrics;
